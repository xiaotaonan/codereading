# 1.1  为什么以及如何阅读代码

您可能会发现自己阅读代码是因为必须这样做，例如在修复、检查或改进现有代码时。 有时您也可能会阅读代码来了解某些东西是如何工作的，就像我们工程师倾向于检查任何带有可打开盖子的东西的内部结构一样。 您可以阅读代码来寻找可重用的材料，或者（我们希望，这种情况很少，但在读完本书后更常见）纯粹是为了您自己的乐趣，作为文学。 针对上述每个原因的代码阅读都有其自己的一套技巧，强调您技能的不同方面。

此部分我感激Dave Thomas的建议。

## 1.1.1 代码即文学

迪克·加布里埃尔 (Dick Gabriel) 指出，我们的职业是少数几个不允许作家阅读彼此作品的创意职业之一 [GG00]。

所有权规则的影响导致不存在像文学一样的软件体。 就好像所有作家都有自己的私人公司，只有梅尔维尔公司的人才能读《白鲸》，只有海明威公司的人才能读《太阳照常升起》。 你能想象在这种情况下发展出丰富的文学作品吗？ 在这种情况下，既不可能有文学课程，也不可能有写作教学方法。 我们期望人们在这种确切的背景下学习编程吗？

开源软件 (OSS) 改变了这一点：我们现在可以访问数百万行代码（质量参差不齐），我们可以阅读、批评和改进这些代码，并从中学习。 事实上，许多促成数学定理作为科学传播工具取得成功的社会过程也适用于开源软件。 大多数开源软件程序已经

- 以源代码方式记录、发布和审查
- 讨论、内化、概括和释义
- 用于解决实际问题，通常与其他程序结合使用

培养成花时间阅读其它作者高质量代码的小习惯。就如阅读高质量的散文可以丰富您的词汇量，激发您的想象力，并且开拓您的视野，查阅一个设计优良软件系统的原理将会教授您新的架构模式、数据结构、编码方法、算法、样式和文档规范，应用编程接口（APIs）,或者甚至一个新的计算机语言。阅读高质量的代码也可能
会提高您对所产生代码的标准。

在你代码阅读的旅程中，你将会不可避免地遇到最好避免这样做的一个例子的代码（反例）。能够快速的从垃圾代码中区分出优秀代码是一个有价值的技能；接触一些类似的代码反例将会有助你开发这样的技能。你可以通过如下的特征来轻松地辨别低质量的代码：

- 不一致的代码风格
- 弄巧成拙或者不可读的结构
- 明显的逻辑错误或者遗漏
- 过度使用不可移植的结构
- 缺少维护

你无论如何，不能期望少写代码来学习编程；如果你像阅读文学作品一样阅读代码，你是在浪费自己的时间，特别是考虑到你现在可以访问到大量的优秀代码。

问问你自己：我现在阅读的代码是这一类代码中最好的吗？开源运动的一个优势就是成功的软件项目和想法被激励竞争以提高它们的结构和功能。我常常在一个软件设计上花大量的时间看2至3遍。你所需要的功能，通过关键字在网上进行检索，将会轻松的引导你找到有竞争性的完成结果。

有选择性的阅读代码，并且在你的头脑中形成目标。你在尝试学习新的模式，一种新的编码风格，一种满足某些需求的方法吗？或者，你可能会发现你在浏览代码过程中会偶然获得一些金点子。在这种情况下，准备去详细的学习你所不知道的有趣的部分：语言特性（即使你深入理解一门语言，由新特性发展而成的现代语言）、APIs、算法、数据结构、架构和设计模式。

留意和欣赏可能会发生特殊实现风格的特别的非功能需求的代码。可移植需求，时间或者空间效率，可读性，或者甚至混淆可以产生具有非常奇特个性的代码。

- 我们已经看到使用6个字母的外部标识符来保持和旧一代链接器的可移植性
- 有一些高效的算法的实现比简单的算法要复杂两个数量级（从源代码行数的角度看）
- 嵌入式或者内存受限的应用等代码（考虑到各种GNU/Linux或者软盘发行的FreeBSD）可以尽可能的节省几个字节的空间
- 编写代码证明算法的功能可能会用到特别长的标识符
- 一些应用领域，比如写保护方案，可能会需要不可读的代码，尝试去阻止逆向工程工作（往往是白费的）

当前阅读的代码涉及上述目录时，记住具体的非功能需求，去看你的同事是如何实现这些非功能需求的。

一些时候你会发现你在一个完全陌生的环境下阅读代码（计算机语言、操作系统或者API）。

有时您可能会发现自己在完全陌生的环境（计算机语言、操作系统或 API）中阅读代码。 如果对编程和底层计算机科学概念有基本的熟悉，在许多情况下，您可以使用源代码来自学新环境的基础知识。 不过，从小程序开始阅读； 不要立即投入到大型系统的研究中。 构建您学习的程序并运行它们。 这将为您提供有关代码应如何工作的即时反馈和成就感。 下一步涉及主动更改代码以测试您的理解。 再次强调，从小的改变开始，逐渐扩大其范围。 您积极参与实际代码可以快速教会您新环境的基础知识。 一旦您认为自己已经掌握了它们，请考虑投入一些精力（可能还有一些现金）以更结构化的方式学习环境。 阅读相关书籍、文档或手册页，或参加培训课程； 这两种学习方法是相辅相成的。

另一种可以积极阅读现有代码的方法是，将现有代码作为文献进行改进。 与其他文字作品相比，软件代码是一个不断改进的实时工件。 如果代码对您或您的社区有价值，请考虑如何改进它。 这可能涉及使用更好的设计或算法、记录某些代码部分或添加功能。 开源代码通常没有很好的文档记录； 考虑将您对代码的理解重新投入到改进的文档中。 在处理现有代码时，与作者或维护者协调工作，以避免重复工作或产生不好的感觉。 如果您的更改可能很大，请考虑成为并发版本系统 (CVS) 提交者 - 有权直接向项目源代码库提交代码的个人。 将您从开源软件获得的好处视为一笔贷款； 想办法通过回馈开源社区来回报它。

## 1.1.2 模范代码

在某些情况下，您可能会想知道特定功能是如何实现的。 对于某些应用课程，您可能可以在标准教科书或专业出版物和研究文章中找到问题的答案。 然而，在许多情况下，如果您想知道“他们是如何做到这一点的”，没有比阅读代码更好的方法了。 代码读取也可能是创建与给定实现兼容的软件的最可靠方法。

使用代码作为示例时的关键概念是灵活。 准备好使用多种不同的策略和方法来理解代码的工作原理。 从您可能找到的任何文档开始（参见第 8 章）。 正式的软件设计文档是理想的选择，但即使是用户文档也可能有所帮助。 实际使用系统感受一下它的外部接口。 了解您到底在寻找什么：系统调用、算法、代码序列、体系结构？ 制定一个能够发现你的目标的策略。 不同的搜索策略对于不同的目的是有效的。 您可能需要跟踪指令执行序列、运行程序并在战略位置放置断点，或者以文本方式搜索代码以查找某些特定代码或数据元素。 工具（参见第 10 章）将在这方面为您提供帮助，但不要让其中之一占据您的注意力。 如果一个策略不能很快产生你想要的结果，就放弃它并尝试不同的方法。 请记住，您要查找的代码就在那里； 你只需要找到它。

一旦找到所需的代码，就研究它，忽略不相关的元素。 这是您必须学习的技能。 本书中的许多练习都会要求您准确执行此任务。 如果您发现很难理解原始上下文中的代码，请将其复制到临时文件中并删除所有不相关的部分。 这个过程的正式名称是切片（参见第 9.1.6 节），但是您可以通过检查我们如何在本书带注释的代码示例中非正式地应用它来了解这个想法。

## 1.1.3 维护

在其他情况下，代码实际上可能需要修复，而不是示例。 如果您认为在大型系统中发现了错误，则需要策略和策略来让您以越来越详细的级别阅读代码，直到找到问题。 本例中的关键概念是使用工具。 使用调试器、编译器的警告或符号代码输出、系统调用跟踪器、数据库的结构化查询语言 (SQL) 日志记录工具、数据包转储工具和 Windows 消息间谍程序来定位错误的位置。 （有关工具如何帮助您阅读代码的更多信息，请参阅第 10 章。）从问题表现形式到问题根源检查代码。 不要走不相关的路径。 使用调试支持编译程序，并使用调试器的堆栈跟踪工具、单步执行以及数据和代码断点来缩小搜索范围。

如果调试器不配合（调试在后台运行的程序，例如守护程序和 Windows 服务、基于 C++ 模板的代码、Servlet 和多线程代码有时非常困难），请考虑在程序的战略位置添加打印语句 执行路径。 检查 Java 代码时，请考虑使用 AspectJ 插入仅在特定情况下执行的程序代码元素。 如果问题与操作系统接口有关，系统调用跟踪工具通常会指导您非常接近问题。

## 1.1.4 发展

在大多数情况下（根据某些测量，超过 80% 的时间），您阅读代码不是为了修复错误，而是为了添加新功能、修改其现有功能、使其适应新的环境和要求，或者重构它以增强其功能。 非功能性品质。 这些情况下的关键概念是对您正在检查的代码范围进行选择性； 在大多数情况下，您实际上必须了解整个系统实现的一小部分。 在实践中，你可以通过选择性地理解和更改一两个文件来修改一个百万行的系统（例如典型的内核或窗口系统）； 我强烈建议您努力体验这种手术成功后所带来的令人振奋的感觉。 下面概述了有选择地处理大型系统的各个部分的策略。

- 定位你感兴趣的代码
- 独自理解特殊的部分
- 在剩余的代码中推断代码片段间的关系

当向系统添加新功能时，您的首要任务是找到类似功能的实现，以用作您将要实现的功能的模板。 同样，当修改现有功能时，您首先需要找到底层代码。 要从功能的功能规范转到代码实现，请遵循字符串消息，或使用关键字搜索代码。 例如，要查找 ftp 命令的用户身份验证代码，您可以在代码中搜索密码字符串：

netbsdsrc/usr.bin/ftp/util.c:265–267

```
if (pass == NULL)
    pass = getpass("Password:");
n = command("PASS %s", pass);
```

找到该功能后，研究其实现（遵循您认为相关的任何代码部分），设计新功能或添加内容，并找到其影响区域 - 将与新代码交互的其他代码部分。 在大多数情况下，这些是您需要彻底理解的唯一代码部分。

使代码适应新环境是一项不同的任务，需要另一组策略。 在某些情况下，这两种环境提供类似的功能：您可能将代码从 Sun Solaris 移植到 GNU/Linux 或从 Unix 系统移植到 Microsoft Windows。 在这些情况下，编译器可能是您最有价值的朋友。 从一开始，假设您已经完成任务并尝试编译系统。 按照编译和链接错误的指示有条不紊地修改代码，直到以干净的构建周期结束，然后验证系统的功能。 您会发现这种方法极大地减少了您需要阅读的代码量。 修改函数、类、模板或数据结构的接口后，您可以遵循类似的策略。 在许多情况下，您不需要手动定位更改的影响，而是按照编译器的错误或警告消息来定位问题点。 对这些区域的修复通常会产生新的错误； 通过这个过程，编译器将为您揭示受您的代码影响的代码位置。

当代码的新环境与旧环境完全不同时（例如，将命令行工具移植到图形窗口环境时的情况），您将不得不采用不同的方法。 在这里，最大限度地减少代码阅读工作的唯一希望是关注旧代码和新环境之间的接口不同的地方。 在我们概述的示例中，这意味着专注于用户交互代码并完全忽略系统的所有算法方面。

一种完全不同的代码演变变化涉及重构。 随着某些类型的开发工作采用极限编程和敏捷编程方法，这些变化变得越来越重要。 重构涉及对系统的更改，保持其静态外部行为不变，但增强其一些非功能性品质，例如其简单性、灵活性、可理解性或性能。 重构与整容手术有一个共同的属性。 重构时，您从一个可用的系统开始，并且希望确保最终得到一个可用的系统。 一套相关的测试用例将帮助您履行此义务，因此您应该从编写它们开始。 一种类型的重构涉及修复已知的问题点。 在这里，您必须了解旧代码部分（这就是本书的内容），设计新的实现，研究它对与您的代码交互的代码的影响（在许多情况下，新代码将是直接替换） ，并实现改变。

另一种类型的重构涉及在软件系统上花费一些“优质时间”，积极寻找可以改进的代码。 这是您需要全面了解系统设计和架构的少数情况之一； 大规模重构可能比小规模重构带来更多好处。 第 6 章讨论了理清大型系统的方法，而第 9 章则概述了如何从代码转向系统架构。 当阅读代码来寻找重构机会时，您可以通过从系统架构开始并向下查看越来越详细的细节来最大化您的投资回报。

## 1.1.5 重用

您可能还会发现自己正在阅读代码来寻找要重用的元素。 这里的关键概念是限制您的期望。 代码可重用性是一个诱人但难以捉摸的概念； 限制你的期望，你就不会失望。 编写可重用的代码非常困难。 多年来，很少有软件能够经受住时间的考验并在多种不同的情况下重用。 软件部件在经过优雅的扩展和迭代调整以在两个或三个不同的系统上工作后，通常会成为重用候选者； 在专门开发的软件中这种情况很少见。 事实上，根据COCOMO II软件成本模型[BCH
+95](netbsdsrc/usr.bin/ftp/util.c:265–267)，制作可重用软件可以增加多达 50% 的开发工作量。

当寻找可在您面临的特定问题中重用的代码时，首先隔离将解决您的问题的代码。 在大多数情况下，通过系统代码进行基于关键字的搜索将指导您实施。 如果您想要重用的代码很棘手、难以理解和隔离，请查看更大粒度的包或不同的代码。 举个例子，不要费力去理解代码片段与其周围元素的复杂关系，而是考虑使用代码所在的整个库、组件、进程甚至系统。

另一项重用活动涉及主动检查代码以挖掘可重用的块。 在这里，您最好的选择是寻找已经重用的代码，可能是在您正在检查的系统中。 表明可重用代码的积极迹象包括使用合适的打包方法（参见第 9.3 节）或配置机制。

### 1.1.6 检查

最后，在某些工作环境中，代码阅读任务可能是您工作描述的一部分。 许多软件开发方法都使用技术评审，例如演练、检查、循环评审和其他类型的技术评估，作为开发过程的组成部分。 此外，在应用极端编程方法的同时练习结对编程时，您经常会发现自己在阅读合作伙伴编写的代码。 在这种情况下阅读代码需要不同程度的理解、欣赏和警觉。 这里你需要彻底。 检查代码以发现功能和逻辑中的错误。 我们在页边标记为危险的各种元素（参见左侧的图标）是您应该警惕的一些事情。 此外，你应该准备好讨论你看不到的事情； 验证代码是否满足其所有要求。

代码的非功能性问题应该吸引您同等的注意力。 该代码是否符合您组织的开发标准和风格指南？ 有重构的机会吗？ 零件编码能否更易读或更高效？ 某些元素可以重用现有的库或组件吗？ 在审查软件系统时，请记住它包含的元素多于可执行语句。 检查文件和目录结构、构建和配置过程、用户界面以及系统文档。

软件检查和相关活动涉及大量的人机交互。 使用软件评论作为学习、教学、伸出援手和获得帮助的机会。





